
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads]{llncs}

%\usepackage{amssymb}
\let\proof\relax
\let\endproof\relax
%\let\c@theorem\relax
%\setcounter{tocdepth}{3}
%\usepackage{graphicx}

\usepackage{amsmath}

%
% the following standard packages may be helpful, but are not required
%
%\usepackage{SIunits}            % typset units correctly
\usepackage{courier}            % standard fixed width font
\usepackage[scaled]{helvet} % see www.ctan.org/get/macros/latex/required/psnfss/psnfss2e.pdf
\usepackage{url}                  % format URLs
\usepackage{listings}          % format code
\usepackage{enumitem}      % adjust spacing in enums
\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   % hyperlinks, including DOIs and URLs in bibliography
%% known bug: http://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink


%\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}   % print a hyperlinked DOI

\input{macros}


\urldef{\mailsa}\path|{xkqiu, asolar}@csail.mit.edu|
%\newcommand{\keywords}[1]{\par\addvspace\baselineskip
%\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Decidable Synthesis with Multi-Invocation Specifications}

% a short form should be given in case it is too long for the running head
%\titlerunning{Lecture Notes in Computer Science: Authors' Instructions}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
%\author{Xiaokang Qiu\inst{1}%
%\thanks{Please note that the LNCS Editorial assumes that all authors have used
%the western naming convention, with given names preceding surnames. This determines
%the structure of the names in the running heads and the author index.}%
%\and Armando Solar-Lezama\inst{2}}
%\author{}
%
%\authorrunning{Lecture Notes in Computer Science: Authors' Instructions}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
%\institute{Purdue University \and Massachusetts Institute of Technology
%\url{http://www.springer.com/lncs}
%}
%\institute{}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{Lecture Notes in Computer Science}
\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}

\end{abstract}



\section{Introduction}
\label{sec:intro}


\section{Invariant Synthesis}
\label{sec:invariant}

\begin{figure}
  \begin{displaymath}
    \begin{array}{rcl}
      \multicolumn{3}{c}{d \in \mathbb{Z} \qquad \vecc \in \mathbb{Z}^n \qquad \vecx \equiv (x_1, \dots, x_n)}
      \\
      \\
      \textrm{Constraint}~ \varphi,\varphi_1,\varphi_2 & ::= & \true
      		\mid  \vecc \cdot \vecx \geq d
      		\mid \varphi_1 \wedge \varphi_2
		\mid \varphi_1 \vee \varphi_2
      \\
      \textrm{Term}~ t,t_1,t_2 & ::= & \bot
      		\mid \vecx + \vec{c}
      		\mid \ite(\varphi, t_1, t_2)
    \end{array}
  \end{displaymath}
  \caption{Invariant synthesis problem.}
  \label{fig:invariant-synthesis-problem}
\end{figure}

\begin{definition}[Invariant synthesis problem]
An invariant synthesis problem is a triple $(\pre(\vecx),\trans(\vecx),\post(\vecx))$, where $\pre$/$\post$ are linear arithmet constraints and $\trans$ is a conditional linear arithmetic term, all defined in Figure~\ref{fig:invariant-synthesis-problem}. A solution to $\syn$ is a constraint $\inv(\vecx)$ such that
\begin{itemize}
\item $\forall \vecx: \pre(\vecx) \Rightarrow \inv(\vecx)$
\item $\forall \vecx: \inv(\vecx) \Rightarrow \inv(\trans(\vecx))$
\item $\forall \vecx: \inv(\vecx) \Rightarrow \post(\vecx)$
\end{itemize}
\end{definition}

Intuitively, $(\pre(\vecx),\trans(\vecx),\post(\vecx))$ represents a program with a set of variables $\vecx$. $\pre(\vecx)$ and $\post(\vecx)$ are the pre- and post-conditions, respectively. $\trans(\vecx)$ represents the iterative transition: $\vecx := \trans(\vecx)$. The loop terminates when $\trans(\vecx)$ is evaluated to the special value $\bot$. The goal of the synthesis problem is to find a loop invariant guaranteeing the partial correctness of the program with respect to $\pre$ and $\post$.

Notice that $\trans(\vecx)$ is \emph{constantly updated} from $\vecx$: there exists a constant vector $\vecc$ such that $\trans(\vecx) = \vecx + \vecc$, i.e., for every variable $x_i \in \vecx$, the update is of form $x_i := x_i + c_i$.

\paragraph{Normalization.} 
We assume the synthesis problem is normalized:
\begin{enumerate}
\item in $\trans(\vecx)$, for each occurrence of conditional term $\ite(\varphi, t_1, t_2)$, $\varphi$ is free of disjunction, and $t_1$ is an atomic term of form $\vecx + \vecc$; and for each two occurrences $\ite(\varphi, t_1, t_2)$ and $\ite(\psi, t_3, t_4)$, $\varphi$ and $\psi$ are disjoint;
\item $\pre(\vecx)$ is in Disjunctive Normal Form (DNF);
\item $\post(\vecx)$ is in Conjunctive Normal Form (CNF).
\end{enumerate}
Obviously, any invariant synthesis problem can be converted to the above normal form. 
We call each normalized conditional term $\ite(\varphi, \vecx + \vecc, t_2)$ a \emph{branch}.

\begin{theorem}
For any $\trans(\vecx)$ be a conditional term and any linear arithmetic constraint $\varphi$, there exists another linear arithmetic constraint, denoted as $T_{\trans,\varphi}$, such that $\forall x: \varphi(\vecx) \equiv T_{\trans,\varphi}(\trans(\vecx))$.
\end{theorem}
\begin{proof}
Let $\trans$ be normalized and $\branches(\trans)$ be the set of branches within $\trans$. Then one can construct the formula as follows: $$T_{\trans,\varphi} \equiv \displaystyle \bigvee_{\ite(\varphi, \vecx + \vecc, t_2) \in \branches(\trans)} \varphi(\vecx - \vecc)$$
The formula enumerates all branches and each $\varphi(\vecx - \vecc)$ characterizes the set of values that satisfy the branch guard before transition. Notice that $\varphi(\vecx - \vecc)$ can be converted to a standard linear arithmetic formula: if $\varphi$ is $c_0 \cdot \vecx \geq d$, then $\varphi(\vecx - \vecc)$ is equivalent to $c_0 \cdot \vecx \geq d + c_0 \cdot c$; if $\varphi$ is a boolean combination of atomic formulas, then $\varphi(\vecx - \vecc)$ can be converted recursively.
\end{proof}

\begin{definition}[Region]
For each branch $\ite(\varphi, \vecx + \vecc, t_2)$ and each constant vector $\vec{d} < \vecc$, we define a region $R_{\varphi, \vec{d}}$ as $\varphi \wedge (\vecx \mod \vecc = \vec{d})$.
\end{definition}

\bibliographystyle{splncs03}

\bibliography{refs}

\appendix
%\section*{Appendices}
%See the supplemental material submitted with this paper.
%\section{Concrete and Abstract Semantics of \Lang}
%\include{appendix}

\end{document}
